package main

import (
	"fmt"
	"image"
	"os"
	"sort"
	"time"
)

func genSMW() (*smw, error) {
	smw := initSMW()

	color, err := initColor()
	if err != nil {
		return smw, err
	}

	image, err := initImage()
	if err != nil {
		return smw, err
	}

	points, err := initPoints()
	if err != nil {
		return smw, err
	}

	for charact, point := range points {
		smw.ASCII[charact] = pixel2Char(image, point, color)
	}

	for color, char := range color.mapping {
		if char == chars[0] {
			color = ";;"
		}
		smw.Palette[char] = color
	}

	return smw, nil
}

func pixel2Char(img image.Image, point image.Point, color *color) []string {
	chars := make([]string, height)
	for y := 0; y < height; y++ {
		line := make([]byte, width*2)
		for x := 0; x < width; x++ {
			r, g, b, _ := img.At(x+point.X, y+point.Y).RGBA()
			rgb := fmt.Sprintf("%d;%d;%d", r>>8, g>>8, b>>8)
			char := color.char(rgb)
			line[2*x] = char
			line[2*x+1] = char
		}
		chars[y] = string(line)
	}

	return chars
}

func main() {
	smw, err := genSMW()
	if err != nil {
		fmt.Printf("generate smw.go error: %v", err)
		return
	}

	file, err := os.Create(output)
	if err != nil {
		fmt.Printf("generate smw.go error: %v", err)
		return
	}
	defer file.Close()

	var charSlice []byte
	var characterSlice, actionSlice []string
	for char := range smw.Palette {
		charSlice = append(charSlice, char)
	}
	for character := range characters {
		characterSlice = append(characterSlice, character)
	}
	for action := range actions {
		actionSlice = append(actionSlice, action)
	}

	sort.Slice(charSlice, func(i, j int) bool {
		return charSlice[i] < charSlice[j]
	})
	sort.Strings(characterSlice)
	sort.Strings(actionSlice)

	fmt.Fprintf(file, "// code generated by generator at %s\n\n", time.Now().Format("2006-01-02 15:04:05"))
	fmt.Fprintf(file, "package main\n\n")
	fmt.Fprintf(file, "var (\n")
	fmt.Fprintf(file, "    characters = []string{\n")
	for _, character := range characterSlice {
		fmt.Fprintf(file, "        \"%s\",\n", character)
	}
	fmt.Fprintf(file, "    }\n\n")
	fmt.Fprintf(file, "    actions = []string{\n")
	for _, action := range actionSlice {
		fmt.Fprintf(file, "        \"%s\",\n", action)
	}
	fmt.Fprintf(file, "    }\n\n")
	fmt.Fprintf(file, "    palettes = map[byte]string{\n")
	for _, char := range charSlice {
		fmt.Fprintf(file, "        '%c': \"%s\",\n", char, smw.Palette[char])
	}
	fmt.Fprintf(file, "    }\n\n")
	fmt.Fprintf(file, "    char byte = '%c' // represent background char", chars[0])
	fmt.Fprintf(file, "    \n\n")
	fmt.Fprintf(file, "    ASCII = map[string][]string{\n")
	for _, character := range characterSlice {
		for _, action := range actionSlice {
			fmt.Fprintf(file, "        \"%s.%s\": {\n", character, action)
			for _, line := range smw.ASCII[character+"."+action] {
				fmt.Fprintf(file, "            \"%s\",\n", line)
			}
			fmt.Fprintf(file, "        },\n")
		}
	}
	fmt.Fprintf(file, "    }\n")
	fmt.Fprintf(file, ")\n")

	fmt.Println("generate smw.go succeed")
	return
}
